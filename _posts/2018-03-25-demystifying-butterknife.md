---
title: Demystifying Butterknife
toc: true
toc_label: Modules
toc_icon: book
date: 2018-03-25 20:00:00 +0530
excerpt: Walk through of Butterknife codebase
header:
  overlay_image: /assets/images/demystifying-butterknife-header.jpg
  overlay_filter: 0.2
  caption: "Photo: [Peter Lewis](https://unsplash.com/photos/1L_m0MpmpEM)"
---
Reading source code, especially of the programs and libraries you use, is quite useful in understanding how it is built. Sometimes, it’d be helpful if one can explained how code is structured and how to deconstruct it. Here is my attempt at writing down my thoughts on Butterknife code, which can potentially help new developers.

***

In this post, we will be uncovering the magic and provide a commentary on the library.

Butterknife is majorly composed of three pieces
* annotations
* annotation processor
* runtime library

## Annotations
Defines all the `BindView` annotation and the like that you use in view code. You can see them all [here](https://github.com/JakeWharton/butterknife/tree/8.8.1/butterknife-annotations/src/main/java/butterknife).

{% gist 5e44378e105f6f0f33ccc8b3043a0d91 Annotations %}

## Annotation processor
This is the most interesting part of Butterknife. The implementation is simple(ish). The processor says it’s interested in all the Butterknife annotations. Then the compiler calls the processor with all the elements annotated with these annotations.  It creates the `XActivity_ViewBinding` class. Let’s focus on the `BindView` annotation, others behave similarly (listeners are slightly different). The crux of `parseBindView` is in [lines 475-499](https://github.com/JakeWharton/butterknife/blob/8.8.1/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java#L475-L499).

{% gist 5e44378e105f6f0f33ccc8b3043a0d91 ButterKnifeProcessor-parseBindView.java %}

Here is a [sample _ViewBinding class](https://github.com/ChaitanyaPramod/ButterknifeDemo/blob/master/build/generated/source/apt/release/com/chaitanyapramod/butterknifedemo/MainActivity_ViewBinding.java) generated by the processor.
{% gist 5e44378e105f6f0f33ccc8b3043a0d91 GeneratedViewBinding.java %}

Listeners are implemented with little more complexity, mainly in `parseListenerAnnotation`, specifically [lines 1139-1164](https://github.com/JakeWharton/butterknife/blob/8.8.1/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java#L1139-L1164) and [1204-1213](https://github.com/JakeWharton/butterknife/blob/8.8.1/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java#L1204-L1213). If we skip all the error-checking, the method `parseListenerAnnotation` matches the parameters from the Android listener which are used in the bound method and passes off the required params to `BindingSet.Builder#addMethod`.

{% gist 5e44378e105f6f0f33ccc8b3043a0d91 ButterKnifeProcessor-parseListenerAnnotation.java %}

See Jake Wharton’s [talk on Annotation Processor](https://speakerdeck.com/jakewharton/annotation-processing-boilerplate-destruction-square-waterloo-2014) to get more details of how one is built.

## Runtime library
This is a utility library and some sugar. The utilities are used from the generated code and the `Butterknife` class. When you call `Butterknife.bind()`, it reflectively loads the processor-generated class, which is named `your-view-class-name + "_ViewBinding"` and constructs an instance of the class.

{% gist 5e44378e105f6f0f33ccc8b3043a0d91 Butterknife-createBinding.java %}

The `Butterknife` class is not really required to make use of the binder. In fact, it adds runtime reflection cost. You can instead use the generated class directly. This is the approach Dagger 2 has taken as well.

{% gist 5e44378e105f6f0f33ccc8b3043a0d91 NoReflection.java %}

## Bonus: The Gradle plugin
The gradle plugin has a very simple function. It lets you use Butterknife in library modules. But why can’t you use Butterknife in library modules like regular application modules? Because the element value in an annotation can only be a constant value for primitive types[^1][^2]. But the `R` class generated by Android Gradle plugin doesn’t make the ID values constant in library modules. If libraries had their resource IDs final, then the IDs could collide when building the final apk. So your compile step will complain loudly if you write
```java
@BindView(R.id.viewid) View idView;
```
You could not use Butterknife in library modules earlier, that is until Gautam Korlam [contributed](https://github.com/JakeWharton/butterknife/pull/613) a Gradle plugin which clones `R` as `R2` with final values for resources. Now you can use `@BindView(R2.id.viewid) View idView` in library modules without worry. Most of the interesting work is done in the [class `FinalRClassBuilder`](https://github.com/JakeWharton/butterknife/blob/8.8.1/butterknife-gradle-plugin/src/main/java/butterknife/plugin/FinalRClassBuilder.java).

{% gist 5e44378e105f6f0f33ccc8b3043a0d91 FinalRClassBuilder.java %}

***

In addition, there’s a module for Android lint checks which I’m not covering here.

Would readers be interested in a walk through building a basic version of Butterknife from scratch?

***

Thanks to [Yashasvi Girdhar](https://twitter.com/yashasvigirdhar) for reading drafts of the post.

[^1]: [https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.28](https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.28)
[^2]: [https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-ElementValue](https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-ElementValue)